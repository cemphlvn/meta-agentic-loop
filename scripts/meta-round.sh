#!/bin/bash
# Meta-Round — Index Enforcement & Alignment Verification
# Scriptically enforces updates to INDEX.md files and verifies alignment

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGIN_DIR="${SCRIPT_DIR}/.."
PROJECT_DIR="${CLAUDE_PROJECT_DIR:-$(dirname "$PLUGIN_DIR")}"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
DATE_ONLY=$(date -u +"%Y-%m-%d")

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m'

#───────────────────────────────────────────────────────────────────────────────
# PHASE 1: SCAN — Discover all modules
#───────────────────────────────────────────────────────────────────────────────

scan_modules() {
    echo -e "${BOLD}[SCAN] Discovering modules...${NC}"

    local modules=""

    # Skills
    if [ -d "${PLUGIN_DIR}/skills" ]; then
        for skill in "${PLUGIN_DIR}"/skills/*/; do
            [ -d "$skill" ] && modules="${modules}skill:$(basename "$skill")\n"
        done
    fi

    # Agents
    if [ -d "${PLUGIN_DIR}/.claude/agents" ]; then
        modules="${modules}agents\n"
    fi

    # Processes
    if [ -d "${PLUGIN_DIR}/processes" ]; then
        modules="${modules}processes\n"
    fi

    # Observability
    if [ -d "${PLUGIN_DIR}/observability" ]; then
        modules="${modules}observability\n"
    fi

    echo -e "$modules" | grep -v '^$' | sort | uniq
}

#───────────────────────────────────────────────────────────────────────────────
# PHASE 2: INDEX — Update stale INDEX.md files
#───────────────────────────────────────────────────────────────────────────────

update_index() {
    local module_path="$1"
    local index_file="${module_path}/INDEX.md"

    if [ ! -f "$index_file" ]; then
        echo -e "  ${YELLOW}Creating INDEX.md for $(basename "$module_path")${NC}"
        generate_index "$module_path" > "$index_file"
        return 0
    fi

    # Check if index is stale (module newer than index)
    local index_mtime
    index_mtime=$(stat -f %m "$index_file" 2>/dev/null || stat -c %Y "$index_file" 2>/dev/null || echo 0)
    local newest_file_mtime=0

    while IFS= read -r -d '' file; do
        local file_mtime
        file_mtime=$(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null || echo 0)
        [ "$file_mtime" -gt "$newest_file_mtime" ] && newest_file_mtime="$file_mtime"
    done < <(find "$module_path" -type f -name "*.md" -o -name "*.sh" -print0 2>/dev/null)

    if [ "$newest_file_mtime" -gt "$index_mtime" ]; then
        echo -e "  ${GREEN}Updating INDEX.md for $(basename "$module_path")${NC}"
        generate_index "$module_path" > "$index_file"
    else
        echo -e "  ${NC}INDEX.md current for $(basename "$module_path")"
    fi
}

generate_index() {
    local module_path="$1"
    local module_name
    module_name=$(basename "$module_path")

    cat << EOF
# ${module_name} — Module Index

> Auto-generated by meta-round.sh on ${TIMESTAMP}

## Contents

EOF

    # List files
    find "$module_path" -maxdepth 1 -type f \( -name "*.md" -o -name "*.sh" \) 2>/dev/null | while read -r file; do
        local fname
        fname=$(basename "$file")
        [ "$fname" = "INDEX.md" ] && continue
        echo "- \`${fname}\`"
    done

    # List subdirs
    find "$module_path" -maxdepth 1 -type d 2>/dev/null | tail -n +2 | while read -r dir; do
        local dname
        dname=$(basename "$dir")
        echo "- \`${dname}/\`"
    done
}

update_all_indexes() {
    echo -e "\n${BOLD}[INDEX] Updating indexes...${NC}"

    local updated=0

    # Update module indexes
    for dir in "${PLUGIN_DIR}/skills"/* "${PLUGIN_DIR}/processes" "${PLUGIN_DIR}/observability"; do
        if [ -d "$dir" ]; then
            update_index "$dir"
            ((updated++)) || true
        fi
    done

    # Update top-level index
    if [ -f "${PLUGIN_DIR}/INDEX.md" ]; then
        local index_mtime
        index_mtime=$(stat -f %m "${PLUGIN_DIR}/INDEX.md" 2>/dev/null || echo 0)
        local now
        now=$(date +%s)
        local age=$((now - index_mtime))

        # Refresh if older than 1 hour
        if [ "$age" -gt 3600 ]; then
            echo -e "  ${GREEN}Refreshing top-level INDEX.md${NC}"
            # Just touch timestamp, actual regeneration requires more logic
            touch "${PLUGIN_DIR}/INDEX.md"
        fi
    fi

    echo "$updated"
}

#───────────────────────────────────────────────────────────────────────────────
# PHASE 3: ALIGN — Verify alignment with remembrance
#───────────────────────────────────────────────────────────────────────────────

check_alignment() {
    echo -e "\n${BOLD}[ALIGN] Checking alignment...${NC}"

    local remembrance="${PROJECT_DIR}/.remembrance"
    local claude_md="${PROJECT_DIR}/CLAUDE.md"
    local drifts=0

    # Check shape_shifts are reflected
    if [ -f "$remembrance" ]; then
        local shape_shifts
        shape_shifts=$(grep -c 'shape_shift: true' "$remembrance" 2>/dev/null || echo 0)
        echo -e "  Shape shifts: ${shape_shifts}"

        # Check if recent shape_shifts are in CLAUDE.md
        if [ "$shape_shifts" -gt 0 ] && [ -f "$claude_md" ]; then
            # Simple check: CLAUDE.md should mention remembrance
            if grep -q "remembrance" "$claude_md"; then
                echo -e "  ${GREEN}✓ CLAUDE.md references remembrance${NC}"
            else
                echo -e "  ${YELLOW}⚠ CLAUDE.md may need shape_shift updates${NC}"
                ((drifts++)) || true
            fi
        fi
    fi

    # Check if observability is referenced
    if [ -d "${PLUGIN_DIR}/observability" ]; then
        if [ -f "$claude_md" ] && grep -q "/observe" "$claude_md"; then
            echo -e "  ${GREEN}✓ Observability commands in CLAUDE.md${NC}"
        else
            echo -e "  ${YELLOW}⚠ Observability not in CLAUDE.md${NC}"
            ((drifts++)) || true
        fi
    fi

    if [ "$drifts" -eq 0 ]; then
        echo -e "  ${GREEN}✓ Alignment verified${NC}"
        echo "aligned"
    else
        echo -e "  ${YELLOW}⚠ ${drifts} drift(s) detected${NC}"
        echo "drifting:${drifts}"
    fi
}

#───────────────────────────────────────────────────────────────────────────────
# PHASE 4: TRACK — Log to CHANGES_LOG.md
#───────────────────────────────────────────────────────────────────────────────

track_changes() {
    echo -e "\n${BOLD}[TRACK] Logging changes...${NC}"

    local changes_log="${PLUGIN_DIR}/CHANGES_LOG.md"

    if [ -f "$changes_log" ]; then
        # Count recent changes (in git or by modification time)
        local claude_changes=0
        local meta_changes=0

        # Claude layer changes
        for f in "${PROJECT_DIR}/CLAUDE.md" "${PROJECT_DIR}/.remembrance"; do
            if [ -f "$f" ]; then
                local mtime
                mtime=$(stat -f %m "$f" 2>/dev/null || stat -c %Y "$f" 2>/dev/null || echo 0)
                local now
                now=$(date +%s)
                local age=$((now - mtime))
                [ "$age" -lt 3600 ] && ((claude_changes++)) || true
            fi
        done

        # Meta layer changes
        meta_changes=$(find "${PLUGIN_DIR}" -type f -mmin -60 2>/dev/null | wc -l | tr -d ' ')

        echo -e "  Claude layer changes (1h): ${claude_changes}"
        echo -e "  Meta layer changes (1h): ${meta_changes}"
    else
        echo -e "  ${YELLOW}CHANGES_LOG.md not found${NC}"
    fi
}

#───────────────────────────────────────────────────────────────────────────────
# PHASE 5: PREDICT — Improvement direction
#───────────────────────────────────────────────────────────────────────────────

predict_direction() {
    echo -e "\n${BOLD}[PREDICT] Analyzing improvement direction...${NC}"

    local remembrance="${PROJECT_DIR}/.remembrance"

    if [ -f "$remembrance" ]; then
        # Count truths
        local total_truths
        total_truths=$(grep -c 'truth:' "$remembrance" 2>/dev/null || echo 0)

        # Recent agent activity
        local recent_agents
        recent_agents=$(grep 'agent:' "$remembrance" 2>/dev/null | tail -5 | sed 's/.*agent:[[:space:]]*//' | sort | uniq -c | sort -rn | head -3)

        echo -e "  Total truths: ${total_truths}"
        echo -e "  Recent agent focus:"
        echo "$recent_agents" | while read -r line; do
            [ -n "$line" ] && echo -e "    $line"
        done

        # Prediction based on activity
        local dominant_agent
        dominant_agent=$(echo "$recent_agents" | head -1 | awk '{print $2}')

        case "$dominant_agent" in
            system)
                echo -e "\n  ${CYAN}Prediction: Infrastructure/foundation work continues${NC}"
                echo -e "  Suggested focus: Consolidate gains, document patterns"
                ;;
            orchestrator)
                echo -e "\n  ${CYAN}Prediction: Routing/workflow optimization likely${NC}"
                echo -e "  Suggested focus: Process refinement"
                ;;
            *)
                echo -e "\n  ${CYAN}Prediction: Diversified activity${NC}"
                echo -e "  Suggested focus: Balance development across agents"
                ;;
        esac
    else
        echo -e "  ${YELLOW}Cannot predict without .remembrance${NC}"
    fi
}

#───────────────────────────────────────────────────────────────────────────────
# PHASE 6: REPORT — Summary
#───────────────────────────────────────────────────────────────────────────────

generate_report() {
    local mode="$1"
    local start_time="$2"
    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo -e "\n${BOLD}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}META-ROUND COMPLETE${NC}"
    echo -e "${BOLD}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "  Timestamp: ${TIMESTAMP}"
    echo -e "  Mode: ${mode}"
    echo -e "  Duration: ${duration}ms"
    echo -e "${BOLD}═══════════════════════════════════════════════════════════════${NC}"
}

#───────────────────────────────────────────────────────────────────────────────
# MAIN
#───────────────────────────────────────────────────────────────────────────────

main() {
    local mode="${1:-full}"
    local start_time
    start_time=$(date +%s)

    echo -e "${BOLD}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║                        META-ROUND                              ║${NC}"
    echo -e "${BOLD}║                        ${TIMESTAMP}                  ║${NC}"
    echo -e "${BOLD}╚═══════════════════════════════════════════════════════════════╝${NC}"

    case "$mode" in
        quick)
            # Minimal checks for Stop hook
            update_all_indexes > /dev/null
            check_alignment > /dev/null
            echo -e "${GREEN}Meta-round (quick) complete${NC}"
            ;;
        index)
            scan_modules
            update_all_indexes
            ;;
        align)
            check_alignment
            ;;
        predict)
            predict_direction
            ;;
        full)
            scan_modules
            update_all_indexes
            check_alignment
            track_changes
            predict_direction
            generate_report "$mode" "$start_time"
            ;;
        *)
            echo "Usage: $0 {quick|index|align|predict|full}"
            exit 1
            ;;
    esac
}

main "${1:-full}"
